<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Levelling up as a developer - gabricom</title>

    <link rel="stylesheet" href="css/reset.css"/>
    <link rel="stylesheet" href="css/reveal.css"/>
    <link rel="stylesheet" href="css/theme/gabricom.css"/>
    <link
            rel="stylesheet"
            href="lib/css/@fortawesome/fontawesome-free/css/all.min.css"
    />
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css"/>

    <!-- Printing and PDF exports -->
    <script>
		var link = document.createElement("link");
		link.rel = "stylesheet";
		link.type = "text/css";
		link.href = window.location.search.match(/print-pdf/gi)
			? "css/print/pdf.css"
			: "css/print/paper.css";
		document.getElementsByTagName("head")[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section id="title">
            <img src="img/developer-for-title.jpg" style="width:40%;float:left"/>
            <h4>Levelling up as a developer</h4>
            <p>Best practices for improving code quality and avoid burnout</p>
            <small>
                <p>
                    <a href="https://github.com/gabricom">Gabriele Colombera</a> /
                    <a href="http://twitter.com/gabricom">@gabricom</a><br/>
                </p>
                <p>
                    PUG SONDRIO - 11 Settembre 2019
                </p>
            </small>
        </section>
        <section id="intro">
            <img
                    src="img/gabricom.jpg"
                    style="width:30%;float:left"
                    class="avatar"
            />
            <div style="width:60%;float:right">
                <ul class="fa-ul" style="list-style:none;margin:0;padding:0">
                    <li>
                        <span class="fa-li"><i class="fa fa-user"></i></span>Gabriele
                        Colombera
                    </li>
                    <li>
                        <span class="fa-li"><i class="fa fa-desktop"></i></span>
                        Fullstack developer
                        <img
                                src="img/webtek.svg"
                                style="height: 1em; box-shadow: none; vertical-align: middle;border:0;box-shadow: none;background: none"
                        />
                    </li>
                    <li>
                        <span class="fa-li"><i class="fab fa-github"></i></span>
                        <a href="https://github.com/gabricom">@gabricom</a>
                    </li>
                    <li>
                        <span class="fa-li"><i class="fab fa-facebook"></i></span>
                        <a href="https://facebook.com/gabricom">@gabricom</a>
                    </li>
                    <li>
                        <span class="fa-li"><i class="fab fa-twitter"></i></span>
                        <a href="https://twitter.com/gabricom">@gabricom</a>
                    </li>
                    <li>
                        <span class="fa-li"><i class="fa fa-users"></i></span>
                        Coordinatore PUG Sondrio
                    </li>
                    <li>
                        <span class="fa-li"><i class="fa fa-gamepad"></i></span>
                        Passionate Gamer
                    </li>
                </ul>
            </div>
        </section>
        <section id="sources">
            <h1>Fonti</h1>
            <ul>
                <li>
                    Code Complete - Steve McConnell
                </li>
                <li>
                    Clean Code - Robert C. Martin
                </li>
            </ul>
        </section>
        <section id="cleancode-why">
            <section>
                <h1>WHY? </h1>
                <aside class="notes">
                    Voglio cominciare iniziando a spiegarvi il perchè di questa presentazione.
                    Lo scopo di questa presentazione è per lo più quello di far riflettere sulla scrittura di codice e
                    quali aspetti del nostro lavoro sono i più importanti e magari spronare sopratutto quelli che hanno
                    iniziato da poco
                    a riflettere su alcuni aspetti del mondo della programmazione.
                    Io stesso mi ritenevo un buon programmatore dato che il mio codice funzionava ma poi in realtà una
                    volta partecipato a conferenze come phpday e simili ti rendi conto di non sapere un cazzo e capisci
                    che è importante
                    studiare e riuscire a "livellare" migliorando costantemente nel tempo.
                    Fatevi una domanda..
                </aside>
            </section>
            <section>
                <h2>Scrivete codice così ?</h2>
                <img src="img/meme-cat.webp">
            </section>
            <section>
                <h2>Oppure così ?</h2>
                <img src="img/meme-goodthinking.jpg">
            </section>
            <section>
                <h2>TRUTHS ABOUT CODING</h2>
                <ul>
                    <li>Time reading > Time writing</li>
                    <li>Ti dimentichi il tuo codice in fretta</li>
                    <lI>I membri del tuo team pensano diversamente da te</lI>
                    <li>L'unica costante è il cambiamento</li>
                    <li>Per essere un buon programmatore non basta saper scrivere codice che funzioni</li>

                    <aside class="notes">
                        Queste sono alcune cose che ho imparato nei miei anni da programmatore.
                        Non so quanti di voi si siano trovati in .. questa situazione
                    </aside>
                </ul>
            </section>
            <section>
                <h2>CLEAN CODE SAVES TIME</h2>
            </section>
        </section>
        <section id="meme-01"
                 data-background-image="img/meme-01.jpg"
                 data-background-size="contain"
        >
            <aside class="notes">
                Questa situazione .. a me è successo più di una volta ve lo assicuro.
            </aside>
        </section>
        <section id="meme-02"
                 data-background-image="img/meme-02.png"
                 data-background-size="contain"
        >
            <aside class="notes">
                Il codice può nascondere delle cose meravigliose al suo interno .
            </aside>
        </section>
        <section id="software-building">
            <h2>Costruire software è difficile.</h2>
        </section>
        <section id="software-activities">
            <h2>Attività</h2>
            <div style="float:left;width:50%">
                <img style="width:100%" src="img/fasi-sviluppo.png"/>
            </div>
            <div style="float:left;width:50%">
                <img style="width:100%" src="img/piramide-sviluppo.png"/>
            </div>
            <aside class="notes">
                Le attività che fanno parte della costruzione di un software sono tantissime.
                Oggi ci concentreremo principalmente sulla parte relativa ai requisiti e sulla parte di "Construction"
                in cui si va effettivamente a scrivere codice
                Ognuna di queste fasi è però importante e sarebbe bello se in futuro qualcuno si proponesse per fare
                talk anche su altri aspetti.
                Code Complete si sofferma su ognuna di queste fasi e fa rimandi ad altri libri/fonti per cui lo
                consiglio come punto di partenza per chi voglia iniziare a studiarsi meglio i vari aspetti.
            </aside>
        </section>
        <section id="prerequisites">
            <section>
                <h1>L'importanza dei requisiti</h1>
            </section>
            <section>
                <h3>
                    I requisiti devono descrivere dettagliatamente tutto quello che l'applicazione deve fare
                    e sono il primo passo verso una possibile soluzione.
                </h3>
            </section>
            <section>
                <h3> Il successo di un progetto è già determinato prima ancora che iniziamo a scrivere una riga di
                    codice.<br>
                    Se le basi non sono solide il massimo che si può fare dopo è cercare
                    di contenere i danni al minimo.</h3>
            </section>
            <section>
                <h2>Errori comuni</h2>
                <ul>
                    <li>Non abbiamo le competenze per analizzare i requisiti del progetto nel modo corretto</li>
                    <li>Vogliamo iniziare subito a programmare e quindi passiamo direttamente alla scrittura del
                        codice
                    </li>
                    <aside class="notes">

                    </aside>
                </ul>
            </section>
            <section>
                <p>"If you want to develop high-quality software, attention to quality must be part of
                    the software-development process from the beginning to the end. Attention to
                    quality at the beginning has a greater influence on product quality than attention at the end."
                </p>
                <aside class="notes">
                    If you emphasize quality at the beginning of the project, you plan for, require, and
                    design a high-quality product. If you start the process with designs for a Pontiac Aztek,
                    you can test it all you want to, and it will never turn into a Rolls-Royce. You might
                    build the best possible Aztek, but if you want a Rolls-Royce, you have to plan from the
                    beginning to build one. In software development, you do such planning when you
                    define the problem, when you specify the solution, and when you design the solution.
                    Since construction is in the middle of a software project, by the time you get to con-
                    struction, the earlier parts of the project have already laid some of the groundwork for
                    success or failure. During construction, however, you should at least be able to deter-
                    mine how good your situation is and to back up if you see the black clouds of failure
                    looming on the horizon. The rest of this chapter describes in detail why proper prep-
                    aration is important and tells you how to determine whether you’re really ready to
                    begin construction.
                </aside>
            </section>
            <section>
                <h2>Più si è avanti con il progetto più un requisito errato incide sul costo</h2>
                <img src="img/prereq-damage.png"/>
                <aside class="notes">Paying attention to requirements helps to minimize changes to a system after
                    develop-
                    ment begins. If you find a coding error during coding, you change a few lines of code
                    and work goes on. If you find a requirements error during coding, you have to alter
                    the design to meet the changed requirement. You might have to throw away part of the
                    old design, and because it has to accommodate code that’s already written, the new
                    design will take longer than it would have in the first place.
                </aside>
            </section>
            <section>
                <h3>Imparare a analizzare le funzionalità di un progetto e redarre una lista il più completa possibile
                    possibile di requisiti è quindi importante quanto saper scrivere codice</h3>
            </section>
            <section>
                <h2>Alcuni elementi da considerare</h2>
                <ul style="font-size:1.5rem">
                    <li>Program Organization</li>
                    <li>Major Classes</li>
                    <li>Data design</li>
                    <li>Business Rules</li>
                    <li>User Interface design</li>
                    <li>Resource Management</li>
                    <lI>Security</li>
                    <li>Performance</li>
                    <li>Scalability</li>
                    <li>Interoperability</li>
                    <li>Internazionalization</li>
                    <li>Input/Output</li>
                    <li>Error Processing</li>
                </ul>
            </section>
        </section>
        <!--        <section id="codequality-organization">-->
        <!--            <section>-->
        <!--                <h2>Tecniche per migliorare la qualità</h2>-->
        <!--                <img src="img/defect-detection-rates.png">-->
        <!--            </section>-->
        <!--			<section>-->
        <!--				<img src="img/defect-detection-rate-cumulative.png">-->
        <!--			</section>-->
        <!--        </section>-->
        <section id="wtf">
            <h1>Ma il codice?</h1>
        </section>
        <section id="cleancode-how">
            <section>
                <h1>
                    HOW TO LEVEL UP
                </h1>
            </section>
            <section>
                <h2>TAKE YOUR TIME</h2>
                <ul>
                    <li>Refactor frequently</li>
                    <li>After it works: look at your code and improve it</li>
                    <li>Have no fear to throw things away</li>
                </ul>
            </section>
            <section>
                <h2>KEEP GRINDING</h2>
                <ul>
                    <li>Always question your code with you and others</li>
                    <li>Keep studying</li>
                    <li>Enjoy conferences and stuff</li>
                </ul>
            </section>
            <section>
                <h2>TAKE A BREAK</h2>
                <ul>
                    <li>Sometimes 20 minutes of relax are better than 2 hour of hard-work</li>
                </ul>
            </section>
            <section>
                <h2>The Clean Coder Rule</h2>
                <h4>   Always leave the code
                    cleaner than you found it.</h4>
            </section>
        </section>
        <section id="martin-quote">
            <h2>
                CLEAN CODE
            </h2>
            <p>
                "Any fool can write code that a computer can understand. Good programmers write code that humans can
                understand. "
            </p>
            <p><strong> Martin Fowler </strong></p>
        </section>
        <section id="unknown-quote">
            <h2>
                How do you write Clean Code?
            </h2>
            <p>
                "Imagine that the developer who comes after you is a homicidal maniac who knows where you live."
            </p>
            <p><strong> Unknown </strong></p>
        </section>
        <section id="howto">
            <section>
                <h3>Desirable characteristics of a design</h3>
                <ul>
                    <li>Minimal complexity</li>
                    <li>Ease of maintenance</li>
                    <li>Loose coupling</li>
                    <li>Extensibility</li>
                    <li>Portability</li>
                </ul>
            </section>
            <section>
                <h2>Software’s Primary Technical Imperative: Managing Complexity</h2>
            </section>
            <section>
                <img src="img/design-levels.png">
            </section>
            <section>
                <ul>
                    <li>Identify the objects and their attributes (methods and data)</li>
                    <li>Determine what can be done to each object.</li>
                    <li>Determine what each object is allowed to do to other objects.</li>
                    <li>Determine the parts of each object that will be visible to other objects—which
                        parts will be public and which will be private.
                    </li>
                    <li>Define each object’s public interface.</li>
                </ul>
            </section>
            <section>
                <h2>Form Consistent Abstractions and hide informations</h2>
                <h4>Abstraction is the ability to engage with a concept while safely ignoring some of its
                    details—handling different details at different levels
                </h4>
            </section>
            <section>
                <h2>Keep Coupling Loose</h2>
                <h4>Coupling describes how tightly a class or routine is related to other classes or rou-
                    tines. The goal is to create classes and routines with small, direct, visible, and flexible
                    relations to other classes and routines, which is known as “loose coupling.”
                </h4>
            </section>
            <section>
                <h3>Look for common design patterns</h3>
                <img style="height:50vh" src="img/design-patterns.png">
                <aside class="notes">
                    Design patterns provide the cores of ready-made solutions that can be used to solve
                    many of software’s most common problems. Some software problems require solutions
                    that are derived from first principles. But most problems are similar to past problems,
                    and those can be solved using similar solutions, or patterns.
                </aside>
            </section>
            <section>
                <h2>DRY</h2>
                <h4>Don't repeat yourself!</h4>
            </section>
        </section>
        <section id="solid">
            <section>
                <h1> SOLID </h1>
            </section>
            <section>
                <h2>Single responsibility principle</h2>
                <h4>A class should only have one reason to change</h4>
            </section>
            <section>
                <pre class="stretch">
                    <code class="php">
interface Cart{
    public function getItems();
    public function addItem($item);
    public function removeItem($item);
    public function calculateTotal();
    public function processPayment($account,$amount);
}
                    </code>
                </pre>
            </section>
            <section>
                <pre class="stretch">
                    <code class="php">
interface ProductCollection{
    public function getItems();
    public function addItem(Product $item);
    public function removeItem(Product $item);
}

interface CartPaymentProcessor{
    public function calculateTotal(ProductCollection $productCollection);
    public function processPayment(AccountInterface $account, Amount $amount);
}
                    </code>
                </pre>
            </section>
            <section>
                <h2>Open-closed principle</h2>
                <h4>A Class should be open for extensions, but closed for modification.</h4>
                <aside class="notes">
                    "A class should be easy to extend without changes"
                    That classes should be extended to change functionality, rather than being altered.
                </aside>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
class Programmer
{
    public function code()
    {
      //[...] DO STUFF
    }
}
class Tester
{
    public function test()
    {
      //[...] DO STUFF
    }
}
class ProjectManagement
{
    public function process($member)
    {
        if ($member instanceof Programmer) {
            $member->code();
        } elseif ($member instanceof Tester) {
            $member->test();
        };
        throw new Exception('Invalid input member');
    }
}
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
interface Workable
{
    public function work();
}
class Programmer implements Workable
{
    public function work()
    {
        //[...] DO STUFF
    }
}
class Tester implements Workable
{
    public function work()
    {
        //[...] DO STUFF
    }
}
class ProjectManagement
{
    public function process(Workable $member)
    {
        return $member->work();
    }
}
                    </code>
                </pre>
            </section>
            <section>
                <h2>Liskov substitution principle</h2>
                <h4>Objects should be replaceable by their subtypes without altering how the program works.</h4>
                <aside class="notes">
                    we must make sure that new derived classes are extending the base classes without changing their
                    behavior.
                </aside>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
class Rectangle {

    private $topLeft;
    private $width;
    private $height;

    public function setHeight($height) {
        $this->height = $height;
    }

    public function getHeight() {
        return $this->height;
    }

    public function setWidth($width) {
        $this->width = $width;
    }

    public function getWidth() {
        return $this->width;
    }
    public function area() {
    return $this->width * $this->height;
    }

}
                    </code>
                </pre>
            </section>
            <section>
                <pre class="stretch">
                    <code class="php">
class Square extends Rectangle {

    public function setHeight($value) {
        $this->width = $value;
        $this->height = $value;
    }

    public function setWidth($value) {
        $this->width = $value;
        $this->height = $value;
    }
}
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
 function areaVerifier(Rectangle $r) {
        $r->setWidth(5);
        $r->setHeight(4);

        if($r->area() != 20) {
            throw new Exception('Bad area!');
        }

        return true;
    }
                    </code>
                </pre>
            </section>
            <section>
                <h2>Interface Segregation Principle</h2>
                <h4>Many client-specific interfaces are better than one general-purpose interface</h4>
                <!-- Put more simply: Do not add additional functionality to an existing interface by adding new methods.
Instead, create a new interface and let your class implement multiple interfaces if needed. -->
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
interface Workable
{
    public function canCode();
    public function code();
    public function test();
}
class Programmer implements Workable
{
    public function canCode()
    {
        return true;
    }
    public function code()
    {
        return 'coding';
    }
    public function test()
    {
        return 'testing in localhost';
    }
}
class Tester implements Workable
{
    public function canCode()
    {
        return false;
    }
    public function code()
    {
         throw new Exception('Opps! I can not code');
    }
    public function test()
    {
        return 'testing in test server';
    }
}
class ProjectManagement
{
    public function processCode(Workable $member)
    {
        if ($member->canCode()) {
            $member->code();
        }
    }
}
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
interface Codeable
{
    public function code();
}
interface Testable
{
    public function test();
}
class Programmer implements Codeable, Testable
{
    public function code()
    {
        return 'coding';
    }
    public function test()
    {
        return 'testing in localhost';
    }
}
class Tester implements Testable
{
    public function test()
    {
        return 'testing in test server';
    }
}
class ProjectManagement
{
    public function processCode(Codeable $member)
    {
        $member->code();
    }
}
                    </code>
                </pre>
            </section>
            <section>
                <h2>Dependency inversion principle</h2>
                <h4>Depend upon abstractions, not concretions.</h4>
                <aside class="notes">
                    Essentially, don't depend on concrete classes, depend upon interfaces.
                </aside>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
class SmtpMailer
{
    //methods for mailer
     public function send(string $message){
         //send message through smtp
     }
}
class WelcomeMessageSender
{
    private $smtpMailer;
    public function __construct(SmtpMailer $mailer)
    {
        $this->smtpMailer = $mailer;
    }
    public function sendMessage(){
        $this->smtpMailer->send("WELCOME TO PUG SONDRIO!");
    }
}
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
interface MailerInterface
{
    public function send(string $message);
}
class SmtpMailer implements MailerInterface
{
    public function send(string $message)
    {
        // Send an email via SMTP
    }
}
class SendSlackMailer implements MailerInterface
{
    public function send(string $message)
    {
        // Send a message via Slack
    }
}
class WelcomeMessageSender
{
    private $mailer;
    public function __construct(MailerInterface $mailer)
    {
        $this->mailer = $mailer;
    }
    public function sendMessage(){
        $this->maler->send("WELCOME TO PUG SONDRIO!");
    }
}
                    </code>
                </pre>
            </section>
        </section>
        <section id="clean-code-names">
            <section>
                <h1>Meaningful naming</h1>
            </section>
            <section>
                <h2>Use intention-revealing names</h2>
                <h4>The name of a variable, function, or class, should answer all the big questions. It
                    should tell you why it exists, what it does, and how it is used. If a name requires a comment,
                    then the name does not reveal its intent.</h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
//That's a Drupal 8 trait
protected function t($string, array $args = [], array $options = []) {
    //do stuff
}
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
 /**
   * Translates a string to the current language or to a given language.
   *
   * See \Drupal\Core\StringTranslation\TranslatableMarkup::__construct() for
   * important security information and usage guidelines.
   *
   * In order for strings to be localized, make them available in one of the
   * ways supported by the
   * @link https://www.drupal.org/node/322729 Localization API @endlink. When
   * possible, use the \Drupal\Core\StringTranslation\StringTranslationTrait
   * $this->t(). Otherwise create a new
   * \Drupal\Core\StringTranslation\TranslatableMarkup object.
   *
   * @param string $string
   *   A string containing the English text to translate.
   * @param array $args
   *   (optional) An associative array of replacements to make after
   *   translation. Based on the first character of the key, the value is
   *   escaped and/or themed. See
   *   \Drupal\Component\Render\FormattableMarkup::placeholderFormat() for
   *   details.
   * @param array $options
   *   (optional) An associative array of additional options, with the following
   *   elements:
   *   - 'langcode' (defaults to the current language): A language code, to
   *     translate to a language other than what is used to display the page.
   *   - 'context' (defaults to the empty context): The context the source
   *     string belongs to. See the
   *     @link i18n Internationalization topic @endlink for more information
   *     about string contexts.
   *
   * @return \Drupal\Core\StringTranslation\TranslatableMarkup
   *   An object that, when cast to a string, returns the translated string.
   *
   * @see \Drupal\Component\Render\FormattableMarkup::placeholderFormat()
   * @see \Drupal\Core\StringTranslation\TranslatableMarkup::__construct()
   *
   * @ingroup sanitization
   */
  protected function t($string, array $args = [], array $options = []) {
    //[...]
  }
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
  protected function translate(string $stringToTranslate, array $args = [], array $options = []):string {
    //[...]
  }
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
//BAD
public function calculate(array $array){
    $t=0;
    foreach($array as $r){
        $t+=$r->getPrice()*$r->getQuantity();
    }
    return $t;
}

//GOOD
public function calculateProductsTotal(ProductCollection $products){
    $total = 0;
    foreach($products as $product){
        $total += $product->getPrice() * $product->getQuantity();
    }
    return $total;
}
                    </code>
                </pre>
            </section>
            <section>
                <h2>Avoid disinformation</h2>
                <h4>Don't call something it's not!</h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
class Collection{
    //used for collection of different types of elements
}

class ArrayCollection extends Collection{
    //collection of Array
}

public function something(){
    $userCollection = []; //That's not a collection! Better call that $userGroups or $userArray
}

                    </code>
                </pre>
            </section>
            <section>
                <h2>Make meaningful distinctions</h2>
                <h4>Variable represent different things, and should be named to show that</h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
class ProductInfo{
    //[...]
}

class ProductData{ //you have made the names different without making them mean anything different

    //[...]
}

//BAD
public function copyFileInDirectory($path,$path){

}

//GOOD
public function copyFileInDirectory(string $sourceFilePath,string $destinationDirectoryPath){

}
                    </code>
                </pre>
            </section>
            <section>
                <h2>Use pronunceable names</h2>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
//BAD
class DtaRcrd {
    private $genymdhms;
    private $modymdhms;
    private $pszqint;
    /* ... */
};

//GOOD
class Customer {
    private $generationTimestamp;
    private $modificationTimestamp;;
    private $recordId;
};
                    </code>
                </pre>
            </section>
            <section>
                <h2>Class names should be nouns</h2>
                <h4>Classes lead to objects which are things not actions</h4>
                <h6>Example: Customer,Account,AddressParser,Cart,User,Authenticator</h6>
            </section>
            <section>
                <h2>Method names should start with a verb</h2>
                <h4>Methods are actions performed on and with things</h4>
                <h6>Example: postPayment,deletePage,save,parseDocument</h6>
            </section>
            <section>
                <h2>Pick one word per concept</h2>
                <h4>Using synonyms for the same action, on different objects, is confusing</h4>
                <h6>Example: fetch/retrieve/get </h6>
            </section>
            <section>
                <h2>Add meaningful context and don't add context when is not needed </h2>
                <h4>There are a few names which are meaningful in and of themselves—most are not. Instead,
                    you need to place names in context for your reader by enclosing them in well-named
                    classes, functions, or namespaces. When all else fails, then prefixing the name may be
                    necessary as a last resort.</h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
class Address{

    private $name;
    private $lastName;
    private $street;
    private $postalCode;
    // enough context
}

public function generateReceipt(){
    // [...]

    $name = "something"; //Is that the name of what? better write $addressName;
}
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
class Product{
    public function addDiscountCode($code){
        // ...enough context
    }
}

//prefix needed
public function addProductDiscountCode(Product $product, string $code){

}
                    </code>
                </pre>
            </section>
        </section>
        <section id="clean-code-functions">
            <section>
                <h1>Functions</h1>
            </section>
            <section>
                <h2>Small!</h2>
                <h4>The first rule of functions is that they should be small. The second rule of functions is that
                    they should be smaller than that.</h4>
            </section>
            <section>
                <ul>
                    <li>Functions should fit on a single screen</li>
                    <li>Prefer method no longer than 10 lines</li>
                </ul>
            </section>
            <section>
                <h2>Blocks within statements should be one line long</h2>
                <h4>Probably that line should be a function call. Not only does
                    this keep the enclosing function small, but it also adds documentary value because the
                    function called within the block can have a nicely descriptive name.</h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
Class VehiclesImportCommand{

    //[...]

    public function importVehicles(){
        try{
            foreach($this->xmlDataStream as $vehicleXmlNode){
                try {
                    $this->currentVehicle = new Vehicle();
                    $this->currentNode = $vehicleXmlNode;
                    $this->parseCurrentNodeData();
                    $this->persistCurrentVehicle();
                    $this->confirmCurrentVehicleImport();

                    //[...] Other stuff

                } catch (MissingDataException $exception) {
                    $this->handleVehicleError($exception);
                }
            }
        }
        catch (\Exception $e) {
            $this->addCriticalError($e);
        }
    }
}
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
Class VehiclesImportCommand{

    //[...]

    public function importVehicles(){
        try{
            foreach($this->xmlDataStream as $vehicleXmlNode){
               $this->importVehicleFromXmlNode($vehicleXmlNode);
            }
        }
        catch (\Exception $e) {
            $this->addCriticalError($e);
        }
    }
}
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
Class VehiclesImportCommand{

    //[...]

    public function importVehicles(){
        try{
            $this->importVehiclesFromXmlStream();
        }
        catch (\Exception $e) {
            $this->addCriticalError($e);
        }
    }
}
                    </code>
                </pre>
            </section>
            <section>
                <h2>Do not use else</h2>
                <h4></h4>
            </section>
            <section>
            <pre class="stretch">
    <code class="php">
private function handleInvoiceCreation(Request $request, AbstractInvoice $invoice)
{
    $form = $this->formFactory->create(InvoiceType::class, $invoice);
    $form->handleRequest($request);

    if($this->user->canCreate()) {

        if ($form->isSubmitted() && $form->isValid()) {

            $this->entityManager->persist($invoice);
            $this->entityManager->flush();
            $this->flashBag->addSuccessMessage('Fattura creata con successo');

            $this->entityManager->refresh($invoice);

            return new RedirectResponse(
                $this->router->generate('panel_detail', ['invoice' => $invoice->getId()])
            );
        } else {
            return [
                'form' => $form->createView(),
                'invoice' => $invoice,
            ];
        }

    } else {
        // qualcos altro
    }

}
    </code>
            </pre>
            </section>
            <section>
                <pre class="stretch">
                    <code class="php">
private function handleInvoiceCreation(Request $request, AbstractInvoice $invoice)
{
    $form = $this->formFactory->create(InvoiceType::class, $invoice);
    $form->handleRequest($request);

    if ($this->user->canCreate()) {
        throw new Exception('Non puoi creare una invoice');
    }

    if ($form->isSubmitted() && $form->isValid()) {

        $this->entityManager->persist($invoice);
        $this->entityManager->flush();
        $this->entityManager->refresh($invoice);

        $this->flashBag->addSuccessMessage('Fattura creata con successo');

        return new RedirectResponse(
            $this->router->generate('panel_detail', ['invoice' => $invoice->getId()])
        );
    }


    return [
        'form' => $form->createView(),
        'invoice' => $invoice,
    ];


}


                    </code>
                </pre>
            </section>
            <section>
                <h2>Do one thing!</h2>
                <h4>If the names includes and or doesn't describe all the functionality well it's doing too much</h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
Class ProductHelper(){
    //Generic Name , probably doing a lot of stuff who need to be splitted in subclasses
}

public function GetXmlDataParseNodeCheckIfNotPresentAndPersistVehicleToDatabase(){
    //That's probably wrong
}

class ProductsHtmlRenderer(){

       public function retrieveProducts(){
            return $this->EntityManager->getRepository(Product::class)->findActiveProducts();
            //This function is not related to the HtmlRenderer, the class is doing too much and the name is wrong and deceptive
       }

       public function renderProducts(){
            $products = $this->retrieveProducts();
             //return a html page with products
       }
}

                    </code>
                </pre>
            </section>
            <section>
                <h2>One level of abstraction per function </h2>
                <h4>Don't mix high-level abstract stuff with low-level detail code</h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
public function isOrderFormValid(OrderForm $orderForm){
    $this->checkRequiredData($orderForm);
    $this->userValidator->checkIfUserExist($orderForm->getUser());

    // this is stuff from a different level of abstraction
    if($orderForm->getSecurityCode() !== "pugsondrio"){
        throw new SecurityException("Wrong Security Code");
    }

}

//This is Better
public function isOrderFormValid(OrderForm $orderForm){
    $this->checkRequiredData($orderForm);
    $this->userValidator->checkIfUserExist($orderForm->getUser());
    $this->checkSecurityCode($orderForm->getSecurityCode());

}
                    </code>
                </pre>
            </section>
            <section>
                <h2>The stepdown rule </h2>
                <h4>The code should be readable from top to bottom, descending one level of abstraction per function. </h4>
                <h6>A caller function should always reside above the callee function</h6>
            </section>
            <section>
                <h2>Avoid switch </h2>
                <h4>Use polymorphism instead</h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
class Airplane
{
    // ...

    public function getCruisingAltitude(): int
    {
        switch ($this->type) {
            case '777':
                return $this->getMaxAltitude() - $this->getPassengerCount();
            case 'Air Force One':
                return $this->getMaxAltitude();
            case 'Cessna':
                return $this->getMaxAltitude() - $this->getFuelExpenditure();
        }
    }
}
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
interface Airplane
{
    // ...

    public function getCruisingAltitude(): int;
}

class Boeing777 implements Airplane
{
    // ...

    public function getCruisingAltitude(): int
    {
        return $this->getMaxAltitude() - $this->getPassengerCount();
    }
}

class AirForceOne implements Airplane
{
    // ...

    public function getCruisingAltitude(): int
    {
        return $this->getMaxAltitude();
    }
}

class Cessna implements Airplane
{
    // ...

    public function getCruisingAltitude(): int
    {
        return $this->getMaxAltitude() - $this->getFuelExpenditure();
    }
}
                    </code>
                </pre>
            </section>
            <section>
                <h2>Use as less arguments as possible. Use objects and arrays when you need many arguments</h2>
                <h4>The ideal number of arguments for a function is
                    zero . Three arguments should be avoided where possible. More than three
                     requires very special justification—and then shouldn’t be used anyway. </h4>
            </section>
            <section>
                <h2>Don't use flag arguments </h2>
                <h4>Flag arguments are ugly. Passing a boolean into a function is a truly terrible practice. It
                    immediately complicates the signature of the method, loudly proclaiming that this function
                    does more than one thing. It does one thing if the flag is true and another if the flag is
                    false!</h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
function createFile(string $name, bool $temp = false): void
{
    if ($temp) {
        touch('./temp/'.$name);
    } else {
        touch($name);
    }
}
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
function createFile(string $name): void
{
    touch($name);
}

function createTempFile(string $name): void
{
    touch('./temp/'.$name);
}
                    </code>
                </pre>
            </section>
            <section>
                <h2>Avoid side-effects</h2>
                <h4></h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
public function isCurrentUserActive(){
   $currentUser = $this->securityHandler->getCurrentUser();
   if($currentUser->isActive()){
       return true;
   }
   $this->UserManager->delete($currentUser); // that's another
    return false;
}
                    </code>
                </pre>
            </section>
            <section>
                <h2>Command Query separation</h2>
                <h4>Functions should either do something or answer something, but not both. Either your
                    function should change the state of an object, or it should return some information about
                    that object. Doing both often leads to confusion</h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
class UserAuthenticationService{

    public function login(string $username, string $password){
        $user = $this->getUser($username);
        if($this->passwordEncoder->isPasswordValid($user->getHashPassword())){
            $this->createAuthenticatedSession();
            return $user; // That's bad , create a getCurrentAuthenticatedUser function instead
        }
    }

}
                    </code>
                </pre>
                <aside class="notes"></aside>
            </section>

        </section>
        <section id="clean-code-comments">
            <section>
                <h1>Comments</h1>
            </section>
            <section>
                <h2>Comments = bad code</h2>
                <h4>The proper use of comments is to compensate for our failure to express ourself in
                    code.<br>If you need comments to understand what the code is doing then the code is poorly written.
                </h4>
            </section>
            <section>
                <h2>Good comments</h2>
                <ul>
                    <li>Can be used to describe intent or clarification </li>
                    <li>Can be used to give warnings or consequences</li>
                    <li>Can be used for TODOs <br> <b>but these should be temporary!</b></li>
                </ul>
            </section>
        </section>
        <section id="clean-code-format">
            <section>
                <h1>Formatting</h1>
            </section>
            <section>
                <h2>Add vertical spaces between concepts</h2>
                <h4>
                </h4>
            </section>
            <section>
                <h2>Order methods by depth</h2>
                <h4>
                    if method a depends on b and then c that is the order in which they should appear
                </h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
public function getUsersForRender(){
    $users = $this->userRepository->getUsers();
    return $this->parseUserCollection($users);
}

private function parseUserCollection(ArrayCollection $users){
    $parsedUsers = [];
    foreach($users as $user){
        $parsedUsers[] = $this->parseUser($user);
    }
    return $parsedUsers;
}

private function parseUser(User $user){
    //and so on..
}
                    </code>
                </pre>
            </section>
            <section>
                <h2>Order methods by conceptual affinity</h2>
                <h4>
                    If two methods do similar things put them close together
                </h4>
            </section>
            <section>
                <h2>Limit line length</h2>
                <h4>
                    Don't make readers scroll horizontally if you care for your life
                </h4>
            </section>
            <section>
                <h2>Space between operators and assignment </h2>
                <h4>
                    A bit of horizonal spacing improve readability
                </h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
$income=$promoEarnings+$developmentEarnings+$gifts-$this->getMonthlyExpenses();

$income = $promoEarnings + $developmentEarning + $gifts - $this->getMonthlyExpenses();
                    </code>
                </pre>
            </section>
            <section>
                <h2>Have team standards</h2>
                <h4>
                    Adopt one standard as a team for naming, spacing , and all formatting stuff.
                </h4>
            </section>
        </section>
        <section id="clean-code-errorhandling">
            <section>
                <h2>Use Exceptions instead returning error codes </h2>
                <h4></h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
if (deletePage($page) == E_OK) {
    if ($registry->deleteReference($page->getName()) == E_OK) {
        if ($configKeys->deleteKey($page->getKey()) == E_OK){
            $logger->log("page deleted");
        } else {
            $logger->log("configKey not deleted");
        }
    } else {
        $logger->log("deleteReference from registry failed");
    }
} else {
    $logger->log("delete failed");
    return E_ERROR;
}
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
try {
    deletePage($page);
    $registry->deleteReference(page->getName());
    $configKeys->deleteKey(page->getKey());
}
catch (Exception $exception) {
    $logger->log($exception->getMessage());
}
                    </code>
                </pre>
            </section>
            <section>
                <h2>Don't return null</h2>
                <h4>
                    If you are tempted to return null from
                    a method, consider throwing an exception or returning a SPECIAL CASE object instead
                </h4>
                <h6>When we return null, we are
                    essentially creating work for
                    ourselves and foisting problems upon
                    our callers</h6>
            </section>
            <section>
                <h2>Throw a meaningful exception</h2>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
$user = $userRepository->get('John');
if (null !== $user && $user->isSubscribedTo($notification)) {
 $notifier->notify($user, $notification);
}


interface UserRepository
{
 public function get(string $username): ?User;
}

                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">

interface UserRepository
{
    /**
     * @param string $username
     * @throws UserNotFound
     * @return User
     */
    public function get(string $username): User;
}

final class DbUserRepository implements UserRepository
{
    public function get(string $username): User
    {
        $userRecord = $this->db->fetchAssoc('SELECT * FROM users W');
         if (false === $userRecord) {
            throw new UserNotFound();
         }
        return User::fromArray($userRecord);
    }
}


try {
    $user = $userRepository->get($username);
    if ($user->isSubscribedTo($notification)) {
        $notifier->notify($user, $notification);
    }
} catch (UserNotFound $ex) {
    $this->logger->notice('User was not found', ['username' => $u ];
}

                    </code>
                </pre>
            </section>
            <section>
                <h2>Special Case</h2>
                <h4>A subclass that provides special behavior for particular cases</h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
class UnknownUser extends User
{
    public function username(): string
    {
        return 'unknown';
    }
    public function isSubscribedTo(Notification $notification): b
    {
        return false;
    }
}

//special case factory
class User
{
    public static function unknown(): User
    {
        static $unknownUser = null;
        if (null === $unknownUser) {
            $unknownUser = new UnknownUser();
        }
        return $unknownUser;
    }
}


final class DbUserRepository implements UserRepository
{
    public function get(string $username): User
    {
         $userRecord = $this->db->fetchAssoc('SELECT * FROM users W ');
         if (false === $userRecord) {
         return new UnknownUser();
         }
        return User::fromArray($userRecord);
    }
}

//Checking for special case
if ($user === User::unknown()) {
 //do something
}
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
//Special case object as private nested class
class User
{
    public static function unknown(): User
    {
        static $unknownUser = null;
        if (null === $unknownUser) {
            $unknownUser = new class extends User {
                public function username(): string
                {
                    return 'unknown';
                }
                public function isSubscribedTo(Notification $noti
                {
                    return false;
                }
            };
        }
        return $unknownUser;
    }
}

                    </code>
                </pre>
            </section>
            <section>
                <h2>Don't pass null</h2>
                <h4>
                    Returning null from methods is
                    bad, but passing null into methods
                    is worse.
                </h4>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
class Order
{
    public function __construct(
        Product $product,
        Customer $customer,
        ?Discount $discount
    ) {
        $this->product = $product;
        $this->customer = $customer;
        $this->discount = $discount;
    }
}

final class PremiumDiscount implements Discount
{
    public function apply(float $productPrice): float
    {
        return $productPrice * 0.5;
    }
}
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
class Order
{
    public function __construct(
        Product $product,
        Customer $customer,
        ?Discount $discount //nullable
    ) {
        $this->product = $product;
        $this->customer = $customer;
        $this->discount = $discount;
    }

    public function total(): float{
        $price = $this->product->getPrice();

        if (null !== $this->discount){ //bad code
            $price = $this->discount->apply($price);
        }

        return $price;
    }

}
                    </code>
                </pre>
            </section>
            <section>
                 <pre class="stretch">
                    <code class="php">
class Order
{
    public function __construct(
        Product $product,
        Customer $customer,
        Discount $discount
    ) {
        $this->product = $product;
        $this->customer = $customer;
        $this->discount = $discount;
    }
}

final class NoDiscount implements Discount
{
     public function apply(float $productPrice): float
     {
        return $productPrice;
     }
}

//use example
$order = new Order($product, $customer, new NoDiscount());
                    </code>
                </pre>
            </section>
        <section>
            <h2>Exception Vs Special Case</h2>
            <ul>
                <li>
                    Special Case as default strategy instead of
                    optional parameters
                </li>
                <li>
                    Exceptions break normal ow to split business
                    logic from error handling
                </li>
                <li>
                    Special Case handles exceptional behaviour
                </li>
                <li>
                    Exception emphasizes violated business rule
                </li>
            </ul>
        </section>
            <section>
                <h2>CENTRAL ERROR HANDLER</h2>
                <h4><strong>Do not catch exception</strong><br> unless you have a very good reason</h4>
            </section>
            <section>
                <h2>When to catch exceptions?</h2>
                <h4>Wraps the entire system to handle any uncaught
                    exceptions from a single place</h4>
            </section>
        </section>
        <section id="clean-code-classes">
            <section>
                <h1>Classes</h1>
            </section>
            <section>
                <h2>Class Organization</h2>
                <section>
                 <pre class="stretch">
                    <code class="php">
 //public static constants
 //private static variables
 //private instance variables
 //public functions
 //private functions called by a public function right after the public function itself
                    </code>
                </pre>
                </section>
            </section>
            <section>
                <h2>Encapsulation</h2>
                <h4>
                    Keep variables and functions private if it's not needed to be public or protected. Information hiding is the way to manage complexity
                </h4>
            </section>
            <section>
                <h2>Small!</h2>
                <h4>
                    Keep Classes small by following the single principle responsibility. Class should have only one,
                    and only one reason to change.
                </h4>
            </section>
            <section>
                <h2>Prefer composition over inheritance</h2>
                <h4>

                </h4>
            </section>
        </section>
        <section id="php-tools">
            <section>
                <h1>PHP & QUALITY TOOLS</h1>
            </section>
            <section>
                <h2>
                    Use types!
                </h2>
                <h4>
                    PHP was shit, but now it's better. What's your excuse?
                </h4>
                 <pre class="stretch">
                    <code class="php">
public function addProductToWishlist($product,$user,$wishlistG){
    //stuff
}

public function addProductToWishlist(Product $product, User $user, Wishlist $wishlist): void
{

}
                    </code>
                </pre>
            </section>
            <section>
                <h2>
                    Use phpdocs!
                </h2>
                <h4>Document arguments, return types and exceptions, a good IDE like PHPStorm generate them for you!</h4>
            </section>
            <section>
                <pre class="stretch">
                    <code class="php">
/**
     * @param StockMovementGenerator $stockMovementGenerator
     * @param float $movement
     * @param string $type
     * @param Commission $commission
     *
     * @return StockMovement
     */
    public function generateStockMovement(
        StockMovementGenerator $stockMovementGenerator,
        float $movement,
        string $type,
        Commission $commission
    ): StockMovement {
        if (! $this->isTypeValid($type)) {
            throw new \InvalidArgumentException('Type is not valid');
        }
        $stockMovement = StockMovementFactory::build($stockMovementGenerator);
        $stockMovement->setMovement($movement);
        $stockMovement->setType($type);
        if ($commission !== Commission::notSet()) {
            $stockMovement->setCommission($commission);
        }
        $stockMovement->setRelatedObject($stockMovementGenerator);

        return $stockMovement;
    }
                    </code>
                </pre>
            </section>
            <section>
                <h2>PHP STORM</h2>
                <h4>Probably the best php IDE around</h4>
            </section>
            <section>
                <h2>PHP CS FIXER</h2>
                <h4>Good for setting a standard for formatting in a team. Uses PSR but can be customizable as you wish</h4>
            </section>
            <section>
                <h2>PHP MESS DETECTOR</h2>
                <p>What PHPMD does is: It takes a given PHP source code base and look for several potential problems within that source. These problems can be things like:

                    Possible bugs
                    Suboptimal code
                    Overcomplicated expressions
                    Unused parameters, methods, properties</p>
            </section>
            <section>
                <h2>PHP CODE SNIFFER</h2>
                <h4>Detect violations of a defined coding standard</h4>
            </section>
            <section>
                <h2>PHP STAN</h2>
                <h4>PHPStan focuses on finding errors in your code without actually running it. It catches whole classes of bugs even before you write tests for the code. It moves PHP closer to compiled languages in the sense that the correctness of each line of the code can be checked before you run the actual line.</h4>
            </section>
            <section>
                <h2>That's for another time!</h2>
            </section>
        </section>
        <section>
            <h1>Thanks!</h1>
        </section>
        <section>
            <h1>Q&A</h1>
        </section>
    </div>
</div>

<script src="js/reveal.js"></script>

<script>
	// More info about config & dependencies:
	// - https://github.com/hakimel/reveal.js#configuration
	// - https://github.com/hakimel/reveal.js#dependencies
	Reveal.initialize({
		dependencies: [
			{src: "plugin/markdown/marked.js"},
			{src: "plugin/markdown/markdown.js"},
			{src: "plugin/notes/notes.js", async: true},
			{src: "plugin/highlight/highlight.js", async: true}
		]
	});
</script>
</body>
</html>
